var algorithms = {"jme": {"student_answer": "\"sin(x)\"", "script": "studentExpr (The student's answer, parsed): \n    try(\n        simplify(parse(studentAnswer),[])\n    ,\n        fail(\"Your answer is not a valid mathematical expression\")\n    )\n\ncleanedStudentString (The student's answer as a string, cleaned up): string(studentExpr)\n\nscope_vars (Variables already defined in the scope): \n    definedvariables()\n\nstudentVariables (Variables used in the student's answer): \n    set(findvars(studentExpr))-set(scope_vars)\n\nunexpectedVariables (Unexpected variables used in the student's answer):\n    let(uvars, filter(not (x in settings[\"expectedVariables\"]),x,list(studentVariables)),\n        assert(len(settings[\"expectedVariables\"])=0 or len(uvars)=0,\n            warn(\"You used the unexpected variable \"+uvars[0])\n        );\n        uvars\n    )\n\nfailMinLength (Is the student's answer too short?):\n    assert(settings[\"minLength\"]=0 or len(cleanedStudentString)>=settings[\"minLength\"],\n        multiply_credit(settings[\"minLengthPC\"],\"Your answer is too short\");\n        true\n    )\n\nfailMaxLength:\n    assert(settings[\"maxLength\"]=0 or len(cleanedStudentString)<=settings[\"maxLength\"],\n        multiply_credit(settings[\"maxLengthPC\"],\"Your answer is too long\");\n        true\n    )\n\nforbiddenStrings:\n    filter(x in cleanedStudentString, x, settings[\"forbiddenStrings\"])\n\nforbiddenStringsPenalty:\n    assert(len(forbiddenStrings)=0,\n        multiply_credit(settings[\"forbiddenStringsPC\"],\"Your answer contains the forbidden string <code>\"+forbiddenStrings[0]+\"</code>\")\n    )\n\nrequiredStrings:\n    filter(not (x in cleanedStudentString), x, settings[\"requiredStrings\"])\n\nrequiredStringsPenalty:\n    assert(len(requiredStrings)=0,\n        multiply_credit(settings[\"requiredStringsPC\"],\"Your answer does not  contain the required string <code>\"+requiredStrings[0]+\"</code>\")\n    )\n\ncorrectExpr (The correct answer, parsed): \n    parse(settings[\"correctAnswer\"])\n\ncorrectVars (Variables used in the correct answer): \n    set(findvars(correctExpr))-set(scope_vars)\n\nvRange (The range to pick variable values from): settings[\"vRangeMin\"]..settings[\"vRangeMax\"]#0\n\nvset (The sets of variable values to test against):\n    repeat(\n        dict(map([x,random(vRange)],x,correctVars or studentVariables)),\n        5\n    )\n\nagree (Do the student's answer and the expected answer agree on each of the sets of variable values?):\n    map(\n        resultsEqual(eval(studentexpr,vars),eval(correctexpr,vars),settings[\"checkingType\"],settings[\"checkingAccuracy\"]),\n        vars,\n        vset\n    )\n\nnumFails (The number of times the student's answer and the expected answer disagree): \n    len(filter(not x,x,agree))\n\nnumericallyCorrect (Is the student's answer numerically correct?):\n    if(numFails<=settings[\"maxFails\"],\n        correct(\"Your answer is numerically correct\")\n    ,\n        incorrect(\"Your answer is incorrect\")\n    )\n\nsameVars (Does the student use the same variables as the correct answer?):\n    if(studentVariables=correctVars,\n        true\n    ,\n        incorrect(\"Your answer is incorrect\");\n        end();\n        false\n    )\n\nmark:\n    apply(studentExpr);\n    apply(unexpectedVariables);\n    apply(sameVars);\n    apply(numericallyCorrect);\n    apply(failMinLength);\n    apply(failMaxLength);\n    apply(forbiddenStringsPenalty);\n    apply(requiredStringsPenalty)\n\nas_jme:\n    studentExpr", "settings": "{\n    \"correctAnswer\": \"sin(x)\",\n    \"vRangeMin\": -1,\n    \"vRangeMax\": 1,\n    \"checkingType\": \"absdiff\",\n    \"checkingAccuracy\": 0.00001,\n    \"maxFails\": 0,\n    \"expectedVariables\": [\"x\"],\n    \"minLength\": 0,\n    \"minLengthPC\": 0.5,\n    \"maxLength\": 200,\n    \"maxLengthPC\": 0.5,\n    \"forbiddenStrings\": [],\n    \"forbiddenStringsPC\": 0.5,\n    \"requiredStrings\": [\"x\"],\n    \"requiredStringsPC\": 0.5\n}"}, "numberentry": {"student_answer": "\"1\"", "script": "studentNumber (The student's answer, parsed as a number):\n   if(settings[\"allowFraction\"],\n      parseNumber_or_fraction(studentAnswer,\"en\")\n   ,\n      parseNumber(studentAnswer,\"en\")\n   )\n\nisFraction (Is the student's answer a fraction?):\n   \"/\" in studentAnswer\n\nnumerator (The numerator of the student's answer, or 0 if not a fraction):\n   if(isFraction,\n      parsenumber(split(studentAnswer,\"/\")[0],\"en\")\n   ,\n      0\n   )\n\ndenominator (The numerator of the student's answer, or 0 if not a fraction):\n   if(isFraction,\n      parsenumber(split(studentAnswer,\"/\")[1],\"en\")\n   ,\n      0\n   )\n\ncancelled (Is the student's answer a cancelled fraction?):\n   if(gcd(numerator,denominator)=1,\n      feedback(\"Your fraction is cancelled\");\n      true\n   ,\n      multiply_credit(0.5,\"Your fraction is not cancelled\");\n      false\n   )\n\nvalidNumber (Is the student's answer a valid number?):\n   if(isNaN(studentNumber),\n      warn(\"Your answer is not a valid number\");\n      fail(\"Your answer is not a valid number\")\n   ,\n      feedback(\"Your answer is a valid number\");\n      true\n   )\n\nnumberInRange (Is the student's number in the allowed range?):\n   if(studentNumber>=settings[\"minValue\"] and studentNumber<=settings[\"maxValue\"],\n      correct(\"Your answer is correct\")\n   ,\n      incorrect(\"Your answer is incorrect\");\n      end()\n   )\n\ncorrectPrecision (Has the student's answer been given to the desired precision?):   if(togivenprecision(studentanswer,settings['precisionType'],settings['precision'],false),\n   feedback(\"You gave your answer to the right precision\");\n   true\n,\n   multiply_credit(0.5,\"You gave your answer to the wrong precision\");\n   false\n)\n\nmark (Mark the student's answer):\n    feedback(\"Your answer: \"+studentanswer);\n    apply(validNumber);\n    apply(numberInRange);\n    assert(numberInRange,end());\n    if(isFraction,\n        apply(cancelled)\n    ,\n        apply(correctPrecision)\n    );\n    feedback(\"This is the end of the marking procedure.\")\n \nas_jme (The student's answer, to be reused by other parts):\n    studentNumber", "settings": "{\n    \"minValue\": 1,\n    \"maxValue\": 2,\n    \"precisionType\": \"sigfig\",\n    \"precision\": 1,\n    \"allowFraction\": true\n}"}, "malrules": {"student_answer": "\"x-x^3/3!+x^5/5!-x^7/7!\"", "script": "studentExpr (The student's answer, parsed): \n    try(\n        simplify(parse(studentAnswer),[])\n    ,\n        fail(\"Your answer is not a valid mathematical expression\")\n    )\n\n\nmalrule_feedback:\n    map(\n        assert(not matches(studentExpr,x[0]),\n            feedback(x[1])\n        ),\n        x,\n        settings[\"malrules\"]\n    )\n\nmark:\n    apply(studentExpr);\n    apply(malrule_feedback)\n\nas_jme:\n    studentExpr", "settings": "{\n    \"malrules\": [\n        [\"m_not(m_uses(x))\",\"Your answer does not use the variable $x$\"],\n        [\"m_all(m_pm(m_any(x,x^?,x^?/?!)));terms+m_nothing;rest\",\"It looks like your answer is a series expansion\"],\n        [\"sin(?)\",\"Your answer is of the form $\\\\sin(.)$\"]\n    ]\n}"}, "matrix": {"student_answer": "[[\"1\",\"0\"],[\"0\",\"1\"]]", "script": "rows (The number of rows in the student's answer): len(studentanswer)\n\ncols (The number of columns in the student's answer): len(studentanswer[0])\n\ncorrect_rows (The number of rows in the correct answer): len(settings['correctAnswer'])\n\ncorrect_cols (The number of columns in the correct answer): len(settings['correctAnswer'][0])\n\nnum_cells (The number of cells in the student's answer): rows*cols\n\ncell_indexes (The index of each cell in the student's answer): \n    product(list(0..rows-1), list(0..cols-1))\n\nstudentNumbers:\n    map(map(parseNumber(c, settings['numberStyle']), c, row), row, studentAnswer)\n\nstudentMatrix (The student's answer, with each cell parsed to numbers): \n    matrix(studentNumbers)\n\ninvalid_cells (The positions of the cells in the student's answer which can't be interpreted as numbers):\n    filter(isnan(studentNumbers[p[0]][p[1]]), p, cell_indexes)\n\nany_invalid (Are any of the cells invalid?):\n    assert(len(invalid_cells)=0,\n        warn(\"The following cells can't be interpeted as numbers: \"+join(invalid_cells, ', '));\n        fail(\"Not all of the cells in your answer are valid numbers.\");\n        true\n    )\n\nwrong_precision_cells (The indexes of the cells which are given to the wrong precision):\n    filter(not toGivenPrecision(studentAnswer[p[0]][p[1]], settings[\"precisionType\"], settings['precision'], true), p, cell_indexes)\n\nwrong_precision (Has every cell been given to the correct precision?):\n    assert(len(wrong_precision_cells)=0,\n        multiply_credit(settings['wrong_precision_credit'], \"The following cells are not written to the required precision: \"+join(wrong_precision_cells, ', '))\n    )\n\n\nwrong_size (Does the student's answer have the wrong dimensions?):\n    assert(rows=correct_rows and cols=correct_cols,\n        incorrect(\"Your matrix has the wrong dimensions.\");\n        end()\n    )\n\nrounded_matrix (The student's answer, with each cell rounded to the required precision): \n    map(\n        switch(\n            settings[\"precisionType\"]=\"dp\",\n            precround(c, settings['precision']),\n            settings[\"precisionType\"]=\"sigfig\",\n            siground(c, settings['precision']),\n            c\n        ),\n        c,\n        studentMatrix\n    )\n\ncorrect_cells (The indexes of the cells which are correct):\n    filter(\n        if(p[0]<correct_rows and p[1]<correct_cols,\n            withinTolerance(rounded_matrix[p[0]][p[1]], settings[\"correctAnswer\"][p[0]][p[1]], settings['tolerance']),\n            false\n        ),\n        p, \n        cell_indexes\n    )\n\nmark:\n    apply(any_invalid);\n    apply(wrong_size);\n    if(len(correct_cells)=len(cell_indexes),\n        correct(\"Your answer is correct\")\n    ,\n        if(settings['mark_per_cell'],\n            add_credit(len(correct_cells)/num_cells,\"One or more cells in your answer were incorrect.\")\n        ,\n            incorrect(\"Your answer is incorrect\");\n            end()\n        )\n    );\n    apply(wrong_precision)\n\nas_jme: studentMatrix", "settings": "{\n    \"correctAnswer\": [[1,0],[0,1]],\n    \"numberStyle\": \"en\",\n    \"precisionType\": \"dp\",\n    \"precision\": 1,\n    \"wrong_precision_credit\": 0.5,\n    \"tolerance\": 1e-10\n}"}}